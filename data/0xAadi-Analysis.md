# Analysis Report - Althea Liquid Infrastructure

## Table of Contents
1. [Overview](#overview)
2. [Contracts](#contracts)
3. [Auditing Approach](#auditing-approach)
4. [Architecture](#architecture)
5. [Codebase Quality Analysis](#codebase-quality-analysis)
6. [Mechanism Review](#mechanism-review)
7. [Critical Issues](#critical-issues)
8. [Centralisation Risk](#centralisation-risk)
9. [Systemic Risk](#systemic-risk)

## Overview
This report presents a comprehensive analysis of the Althea Liquid Infrastructure protocol's smart contracts. The audit scrutinizes the contracts' functionality, security measures, and overall code quality, identifying critical issues and providing recommendations for improvement.

## Contracts
The pivotal contracts in this audit for the Althea Liquid Infrastructure protocol are:

- **contracts/LiquidInfrastructureERC20.sol:** This contract is an ERC20 token designed to collect revenue from Liquid Infrastructure NFT contracts and distribute it to token holders. Holders of `LiquidInfrastructureERC20` tokens are entitled to a share of the profits from the associated Liquid Infrastructure NFTs, allowing for passive income generation.

- **contracts/LiquidInfrastructureNFT.sol:** The `LiquidInfrastructureNFT` contract is an ERC721 token representing ownership of a Liquid Infrastructure Account within the Althea network. It is linked to the x/microtx module, which facilitates periodic revenue in ERC20 tokens. The `LiquidInfrastructureERC20` contract uses the `LiquidInfrastructureNFT` to manage the withdrawal and distribution of these tokens to its holders.

- **contracts/OwnableApprovableERC721.sol:** This abstract contract defines key modifiers used by the `LiquidInfrastructureNFT.sol` contract. It ensures that certain functions are only executable by the token owner or an approved delegate, enhancing security and functionality.

## Auditing Approach
During the audit of the Althea Liquid Infrastructure protocol's smart contracts, I conducted a thorough examination of the provided codebase, including the associated test files. My audit strategy encompassed an in-depth review of the Solidity code, with a particular emphasis on security aspects. To validate the functionality and robustness of the contracts, I compiled the code and executed a series of tests across various scenarios. Additionally, I verified the main invariants, explored attack ideas presented by the protocol in the scope. This rigorous analysis allowed me to assess the performance and security safeguards of the contracts under a range of conditions. Furthermore, I confirmed the integrity of the main invariants, brainstormed potential attack vectors, and took into account extra contextual details to ensure a comprehensive and meticulous audit process.

## Architecture
![Althea Liquid Infrastructure Diagram](https://gist.githubusercontent.com/AnandkKumaran/9eeeb398b954d8e0e53db8f04399f61f/raw/9b75d872398f03dada384f06af606537c76faa84/althea.png)

### Liquid Infrastructure NFT
This is the Tokenized Representation of Infrastructure Accounts. It issues a unique NFT (non-fungible token) that represents ownership of a Liquid Infrastructure Account. This account is typically associated with infrastructure involved in an Althea pay-per-forward network, such as internet service provision. The contract is designed to collect periodic revenue. On Althea-L1 chains, this revenue comes from the x/bank module, which conducts microtransactions as the payment layer for Althea networks.

#### Privileged Roles
- **Owner**: The contract owner is the initial holder of the NFT created upon contract deployment. This user has the highest level of privileges, like Setting Balance Thresholds and Withdrawing Balances.

- **Approved User**:These are users who have been granted specific permissions by the contract owner.Their privileges are Withdrawing Balances and Managing Thresholds

#### Functionalities
##### ERC20 Threshold
The contract interacts with the x/microtx module to manage the balance of revenue coins(USDC,USDT) within the Liquid Infrastructure Account. It sets thresholds to determine how much of each token should be retained in the contract, with excess amounts being deposited into the LiquidInfrastructureNFT contract.

##### Withdraw ERC20 Balance
Owners or Approved users of the Liquid Infrastructure Account can withdraw the accumulated ERC20 balances. This allows them to access the funds that have been converted and transferred to the contract.

### Liquid Infrastructure ERC20
The LiquidInfrastructureERC20 contract is an ERC20 token designed to interface with Liquid Infrastructure NFT (Non-Fungible Token) contracts. The primary purpose of the contract is to collect revenue generated by these NFTs and distribute it to the holders of the LiquidInfrastructureERC20 tokens.

#### Privileged Roles
- **Owner**: The owner is the account that deployed the contract and has the highest level of privileges. The Ownable contract from OpenZeppelin provides onlyOwner  modifier that restricts certain functions to be callable only by the owner. The owner has the ability to perform actions such as adding or releasing managed NFTs, approving or disapproving holders, and initiating distributions.

- **Approved Holders**: The approved holders can receive and hold the LiquidInfrastructureERC20 tokens. This role is managed through the HolderAllowlist and the approved holders are entitled to receive revenue through distribution.

#### Functionalities
##### Owner Privileged Functions
- **Approve/Disapprove Holder**: A mechanism to maintain a list of addresses that are authorized (or not authorized) to hold the contract's tokens. This feature is typically used to enforce certain restrictions on who can own or transact with the tokens.

- **Add/Release NFTs**: The Add/Release NFTs functionality refers to the ability to manage a collection of NFTs that the contract interacts with or controls. This functionality allows the contract owner to add new NFTs to the contract's management or release them from the contract's control. 

- **Set Distributable ERC20s**: This is to define and update the list of ERC20 tokens that are eligible for distribution to the token holders. This feature is used for aggregate revenue or rewards in the form of ERC20 tokens and then distributed to the holders of the contract's native token.

- **Mint InfraERC20**: The mint function allows the contract to generate new InfraERC20 tokens. These tokens are typically credited to a specific address. Minting is a privileged action controlled by the contract owner. This ensures that new tokens are created responsibly and in accordance with the token's monetary policy.

##### Withdraw ERC20s from NFTs
This is to withdraw ERC20 tokens that may have accumulated in associated NFT contracts. NFTs associated with real-world assets or digital services that generate revenue. This revenue will be collected in the form of ERC20 tokens, which are held by the NFT contract until they are withdrawn.

This allows the contract to retrieve ERC20 tokens from the NFT contracts it manages. This withdrawal process transfers the accumulated tokens from the NFT contracts to the LiquidInfrastructureERC20 contract.

The contract prevents withdrawal from being performed while a distribution is in progress. This is to ensure the integrity of the distribution process and to prevent state changes that could affect the distribution.

##### Distribute ERC20s
The LiquidInfrastructureERC20 contract aggregates the revenue from the NFT contracts and distributes it among its token holders. The distribution is proportional to the number of tokens each holder owns, meaning that the more tokens a user holds, the larger their share of the revenue.

Users who hold LiquidInfrastructureERC20 tokens can earn additional ERC20 tokens as revenue. This creates an incentive mechanism for users to invest in and hold the LiquidInfrastructureERC20 tokens.

##### Burn InfraERC20
The burn function allows token holders or approved users to destroy a specified amount of InfraERC20 tokens from their balance. The contracts enforce a distribution before burning to maintain consistency in the contract's state, especially while the distribution amount per token is calculated based on the current total supply.

##### Transfer InfraERC20
The ERC20 transfer performs a few additional steps while doing the transfer. The contract checks whether the contract is currently locked for distribution and whether the recipient is an approved holder while performing a transfer. It also adds the recipient to the holders list if they are receiving tokens for the first time.And also  it removes the sender from the holders list if their balance has dropped to zero as a result of the transfer.

## Codebase Quality Analysis
The codebase exhibits a high level of quality by delivering clarity in functionality through self-explanatory code, employing simple functionalities and logic. And, its readability is enhanced due to the well-documented comments. Despite handling complex calculations, the code is inherently explanatory and highly understandable for both auditors and developers.

### Modularity
The codebase demonstrates a high level of modularity, effectively segregating complex logics and operations into separate functions, particularly with the reward distribution. The use of distinct contracts to manage the access control contributes to reducing overall complexity.

### Comments
Insufficient comments throughout the contracts limit the clarity of each function, requiring auditors and developers to invest more time in understanding the functionality. Improving comments to thoroughly explain the various functionalities would greatly enhance the code's accessibility and comprehension.

### Access Controls
The codebase effectively employs access control mechanisms to ensure smooth execution of functions, it falls short in securing some critical functions. The `distribute` and `withdrawFromManagedNFTs` functions are publicly accessible, allowing any user to execute them without proper access checks. This lack of control could lead to scenarios where users initiate distribution or withdrawal processes but do not complete them, consequently burdening other users or the owner with the task of finishing these operations. Such situations could render these vital contract functions idle, disrupting the contract's critical operations until the pending actions are resolved.

### Events
The contracts emit events for all functions that interact with users, which is a crucial feature for tracking and verifying contract activity. However, the events have not been optimized with appropriate indexing, which is a significant oversight. Proper indexing of event parameters is essential for enabling efficient searches and retrievals within event logs. Without indexing, users and applications may face challenges when attempting to filter and access specific event data.

### Error Handling
The contracts exhibit a moderate level of error handling; however, there is room for improvement, particularly in the administrative functions, which currently lack essential validations, such as preventing the addition of duplicate NFTs to the managed NFT list. Additionally, the contracts rely solely on `require` statements for error handling, without utilizing separate error types. To refine the codebase, it is advisable to implement a dedicated library contract that centralizes error definitions. Adopting this strategy would not only enhance the code's structure but also its maintainability, leading to a more robust and clear error handling system.

### Imports
It is advisable for the contracts to utilize named imports consistently throughout the codebase. This practice enhances readability and maintainability by clearly indicating the specific functions, variables, or types that are being imported from external contracts or libraries. 

### Libraries
The contracts currently do not incorporate any libraries. However, it is advisable to consider using a separate library to encapsulate the errors and events in the contracts. This practice can enhance modularity and maintainability within the codebase.

## Mechanism Review
### Deploy Liquid Infrastructure NFTs
Entities utilizing Althea's networking devices deploy LiquidInfrastructureNFTs to tokenize their assets within the ecosystem. By doing so, they create a digital representation of their infrastructure on the blockchain. The process involves setting the Liquid Infrastructure ERC20s contract as the owner of the NFTs, which enables it to manage the assets and withdraw any revenue that exceeds predefined threshold amounts. This approach allows for the seamless collection of revenue generated from the x/bank module.

### Managing Liquid Infrastructure NFTs
The owner of the LiquidInfrastructureERC20s contract has the capability to add or remove LiquidInfrastructureNFTs with the contract. This is achieved through two functions: `addManagedNFT()` and `releaseManagedNFT()`. The `addManagedNFT()` function is designed to onboard new NFTs into the system; however, it lacks a crucial check to verify whether the NFT has already been added. This oversight introduces a risk where, if the owner inadvertently adds the same NFT more than once, the contract does not revert the action. Consequently, when the withdrawal functionality is invoked, it is required to withdraw ERC20 tokens from the NFT contract multiple times, leading to unnecessary gas expenditures.

On the other hand, the `releaseManagedNFT()` function is removing NFTs from the contract's management. It operates under the assumption that there are no duplicate entries in the ManagedNFTs array. However, as previously mentioned, the possibility of duplication exists. The current implementation of `releaseManagedNFT()` only eliminates the first occurrence of the NFT contract in a single transaction, leaving any additional duplicates untouched.

#### Recommendation
To address these issues, it would be prudent to introduce a mapping in parallel with the ManagedNFTs array. This mapping would maintain the index of each NFT address, thereby ensuring the uniqueness of entries in the array and eliminating the need for costly iterations. When the need arises to remove an NFT, the index can be retrieved from the mapping, allowing for efficient removal from the array and effectively preventing any duplication.

Furthermore, the existing `require` statement within the  `releaseManagedNFT()`:

```solidity
// By this point the NFT should have been found and removed from ManagedNFTs
require(true, "unable to find released NFT in ManagedNFTs");
```
is flawed as it will invariably pass, given that the condition is always satisfied. This means that the associated event will be triggered regardless of whether the NFT was actually found or removed from the array. To ensure the integrity of the contract's operations, this require statement should be corrected to accurately reflect the success or failure of the NFT's removal.

Another concern is that neither `addManagedNFT()` nor `releaseManagedNFT()` currently checks for ongoing withdrawal processes. It is essential to ensure that no updates to the NFTs under management are made while a withdrawal is in progress. If a withdrawal is underway, these functions should block any attempts to add or release NFTs until the withdrawal is complete. This safeguard would prevent potential conflicts or inconsistencies during the management of the NFTs, especially in the context of financial operations.

### Managing Distributable ERC20 Tokens
The `setDistributableERC20s()` function is utilized within the `LiquidInfrastructureERC20` contract to establish a new array of ERC20 tokens that are eligible for distribution to token holders. However, this function does not provide the flexibility to add or remove individual ERC20 tokens from the list; it requires setting the entire array at once. While managing a small number of ERC20 tokens may not pose significant issues, the gas costs associated with updating the list can escalate as the number of tokens increases, due to the inherent nature of blockchain transactions and the need to store more data on-chain.

#### Recommendation
The current implementation lacks a safeguard to prevent updates to the distributable ERC20 tokens while a distribution is actively in progress. This oversight could lead to complications if the list of distributable tokens is altered mid-distribution, potentially affecting the accuracy and fairness of the distribution process. 

### Manage LiquidInfrastructureERC20s Holders
The `LiquidInfrastructureERC20` contract functions—`approveHolder()`, `disapproveHolder()`, and `isApprovedHolder()`—designed to manage the list of entities authorized to hold its ERC20 tokens. A dedicated `holders` array within the contract keeps track of all token holder addresses.

Token transfers within the contract are confined to approved holders. Consequently, any address that receives the token is automatically appended to the `holders` array. Being an approved holder is a key criterion for eligibility to receive rewards as well as tokens, which are allocated among those on the approved list. Moreover, approved holders are at liberty to trade their `LiquidInfrastructureERC20` tokens on external markets, thus providing liquidity and facilitating the discovery of the token's market price. 

### Withdraw ERC20s From Liquid Infrastructure NFTs
The `withdrawFromManagedNFTs()` function serves a crucial role in managing the flow of ERC20 tokens from associated NFT contracts. Designed to be publicly callable, this function allows any user to initiate the withdrawal of accumulated ERC20 tokens, such as stablecoins, from the NFT contracts that the `LiquidInfrastructureERC20` oversees. To safeguard against gas-based Denial of Service (DOS) attacks, the function is resistant to excessive gas consumption, ensuring that the withdrawal process remains efficient and secure. However, to maintain the integrity of ongoing reward distributions, the `withdrawFromManagedNFTs()` function cannot be executed while a distribution is in progress, preventing any potential interference with the allocation of rewards to token holders.

### Distribute Rewards to Liquid Infrastructure ERC20s Holders
The `distribute` function in the contract is publicly accessible, enabling any party to trigger the distribution process after the `MinDistributionPeriod` has passed. This functionality guarantees that approved holders can receive their rewards promptly. The rewards are issued in stablecoins, offering a dependable value for the beneficiaries. To counteract potential gas-based Denial of Service (DOS) attacks, the `distribute` function is crafted to be resilient against DOS related to gas limits by facilitating the distribution across several incremental steps. This approach allows for a smooth and secure reward distribution that aligns with the holders' `InfraERC20` token balances.

#### Recommendation
When calculating reward entitlements, it is critical to account for the decimals of the reward tokens to ensure precision. To avoid the common issue of division before multiplication, which can lead to rounding errors and loss of precision, the contract should take a snapshot of the token balances at the start of the distribution cycle. This snapshot will then be used to accurately calculate the reward entitlement for each holder during the distribution process. By multiplying the holder's balance by the reward per token first and then dividing by the total supply, the contract can maintain the integrity of the distribution calculations.

Furthermore, the contract should not include the balances of disapproved holders when calculating the total supply for reward entitlements. If disapproved holders' balances are factored into the total supply, their undistributed portion of rewards will carry over to subsequent distribution rounds. This carryover can create disparities in reward distribution, as future approved holders may receive a share of rewards that were not allocated in previous rounds. To prevent such inequities, only the balances of approved holders should be considered in the calculation of reward entitlements, ensuring a fair and proportional distribution of rewards to eligible participants.

### Liquid Infrastructure ERC20s Operations
#### Mint
The minting functionality is exclusively reserved for the contract owner, ensuring that only the owner can issue new tokens to users. This level of control is crucial for maintaining the integrity of the token's supply and for adhering to any predefined tokenomics. Additionally, the contract stipulates that a distribution must occur before any minting can take place, provided that the `MinDistributionPeriod` has been reached. This requirement ensures that all entitled token holders receive their due rewards before any new tokens are introduced into circulation, thereby preserving the fairness and accuracy of the distribution process.

#### Burn
The burn functionality is accessible to token holders and users who have been granted approval, allowing them to reduce the token supply by destroying a specified amount of their tokens. The contract enforces a rule that requires a distribution to be completed before any new burning actions if the `MinDistributionPeriod` has elapsed. This ensures that existing token holders receive their allocated rewards based on the current supply before any decrease in the total number of tokens occurs, maintaining the equitable distribution of rewards.

#### Transfer
The transfers of tokens are designed to occur exclusively between approved holder addresses. This restriction ensures that only approved holders can receive the token and holding of tokens, aligning with the contract's security and compliance measures. After each transfer, if the recipient's (`to` address) balance increases from zero as a result of the transaction, their address is automatically added to the `holders` array. Conversely, if a sender's (`from` address) balance is depleted to zero during the transfer, their address is promptly removed from the `holders` array, reflecting the change in their token holding status. This dynamic updating of the `holders` array after each transfer maintains an accurate record of current token holders within the contract.

#### Recommendation
```solidity
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        bool stillHolding = (this.balanceOf(from) != 0);
        if (!stillHolding) {
@-->        for (uint i = 0; i < holders.length; i++) {
                if (holders[i] == from) {
                    // Remove the element at i by copying the last one into its place and removing the last element
                    holders[i] = holders[holders.length - 1];
                    holders.pop();
                }
            }
        }
    }
```
The `_afterTokenTransfer` function is designed to update the `holders` array, which tracks the addresses currently holding tokens. As shown in the provided Solidity code snippet, the function includes a loop that checks if the `from` address, after transferring tokens, still holds any tokens.

However, this logic presents a potential inefficiency during the minting process. When new tokens are minted, the `from` address is the zero address (`address(0)`), and since the zero address cannot hold tokens, its balance is always zero. The loop in the `_afterTokenTransfer` function would then be executed unnecessarily, iterating over the entire `holders` array without the possibility of finding an entry for `address(0)` to remove. This unnecessary iteration can result in the contract owner incurring significant gas costs over time, especially as the `holders` array grows. To optimize gas usage and avoid this inefficiency, the loop should be bypassed or excluded from execution during minting operations, ensuring that minting remains cost-effective and does not impact the contract's performance.

During the token burning process within the `LiquidInfrastructureERC20` contract, a significant issue arises where the zero address (`address(0)`) is mistakenly added to the token holders array. See `_beforeTokenTransfer` function. Consequently, each burn transaction triggers the addition of `address(0)` to this array. This erroneous behavior leads to an inflated holders array, which not only consumes unnecessary storage space but also increases the risk of gas griefing. As the array grows with each burn transaction, operations that need to iterate over the array become more gas-intensive, potentially resulting in a systemwide Denial of Service (DOS) if the gas costs exceed block limits, thereby disrupting the contract's and possibly the broader ecosystem's operations.

```solidity
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        require(!LockedForDistribution, "distribution in progress");
        if (!(to == address(0))) {
            require(
                isApprovedHolder(to),
                "receiver not approved to hold the token"
            );
        }
        if (from == address(0) || to == address(0)) {
            _beforeMintOrBurn();
        }
        bool exists = (this.balanceOf(to) != 0);
        if (!exists) {
@-->        holders.push(to);
        }
    }
```

The same flawed logic within the contract does not prevent zero-amount transfers, which can further exacerbate the issue. If a transfer of zero tokens is made to an address with a zero balance, that address is also incorrectly added to the holders array. This can lead to repeated and unnecessary entries in the holders list, compounding the bloating problem. As with the burning issue, this can cause similar complications, including increased gas costs for iterating over the holders array and the potential for a systemwide DOS, affecting the contract's functionality and efficiency.


## Critical Issues
### Decimal Handling and Order of Operations
The current implementation of the `LiquidInfrastructureERC20` contract's distribution process encounters a significant challenge due to the handling of decimal places and the order of operations in calculating entitlements. The logic does not properly account for the decimal differences between `distributableERC20s` tokens such as USDC, USDT, or DAI, which typically have `10^6` decimals, compared to the `InfraERC20` token's total supply with `10^18` decimals. This leads to a situation where division is performed before multiplication, necessitating an impractically high minimum balance of `1 trillion USDC` to initiate the distribution process. To rectify this, the contract should be updated to perform multiplication before division and to scale the `distributableERC20s` tokens to the same decimal precision as `InfraERC20` tokens before calculating entitlements.

### Impact of Excluding Disapproved Holders on Reward Calculation
The `LiquidInfrastructureERC20` contract's distribution logic calculates the entitlement of rewards based on the total supply of tokens, without distinguishing between approved and disapproved holders. As a result, when disapproved holders are excluded from a distribution cycle, their share of the rewards remains undistributed. This undistributed portion is then carried over to the next distribution cycle, where it may be unfairly allocated among a new set of approved holders, potentially including those who have been added since the last cycle. This can lead to a dilution of rewards for existing approved holders who were entitled to a larger share. To ensure equitable distribution, the contract should adjust the entitlement calculation to exclude the balances of disapproved holders from the total supply.

### Necessity of an Emergency Withdrawal Mechanism
The `LiquidInfrastructureERC20` contract's lack of an emergency withdrawal mechanism for undistributed `distributableERC20s` tokens presents a critical issue. This becomes particularly problematic when the contract owner updates the list of distributable tokens using the `setDistributableERC20s` function. If certain tokens are omitted from the updated list, their remaining balance could become locked within the contract with no way to retrieve them. This not only prevents the reallocation of these funds but also poses a risk of permanent loss of assets. Implementing an emergency withdrawal function would enable the contract owner to recover undistributed tokens, ensuring that the contract's assets remain accessible and manageable.

### Attacker Can Inflate the Holder Array with Zero-Token Transfers
The vulnerability has been identified in the `LiquidInfrastructureERC20` contract, where an attacker can exploit zero-token transfers to manipulate/inflate the holder array. This attack involves sending zero-token transactions to an approved holder whose balance is zero. Despite not transferring any actual tokens, this action results in the recipient's address being added to the holder array multiple times.

### Addition of Zero Address to Holder Array on Every Token Burn
The `LiquidInfrastructureERC20` contract exhibits a critical flaw where the zero address (`address(0)`) is automatically added to the `holders` array during every token burn transaction. This occurs due to a lack of proper validation in the `_beforeTokenTransfer` function, which should prevent the zero address from being included in the holder tracking mechanism. The presence of `address(0)` in the `holders` array can lead to unnecessary complications and inefficiencies within the contract's operations, particularly in functions that rely on iterating over the array of token holders.

### Division Before Multiplication in Reward Distribution Calculation
The `LiquidInfrastructureERC20` contract faces an issue in its reward distribution logic due to the order of operations where division is performed before multiplication. This sequence, particularly when using integer arithmetic in Solidity, results in premature truncation of values. Consequently, this leads to incorrect calculations of reward entitlements. The problem is further compounded by the contract's `InfraERC20` token having a different decimal precision (18 decimals) than the distributable ERC20 token, such as USDC, which has 6 decimals. The flaw is located within the `erc20EntitlementPerUnit` calculation in the `_beginDistribution` function. The current implementation, due to the handling of decimal places and the order of operations for calculating entitlements, inadvertently necessitates a prohibitively high minimum balance of `1 trillion USDC` to initiate the distribution process.
This high threshold is impractical and hinders the contract's ability to conduct distributions.

## Centralisation Risk
The Althea Liquid Infrastructure protocol utilizes the `LiquidInfrastructureERC20` contract, which assigns critical responsibilities to the Owner role. This role is pivotal for executing various administrative tasks, including approving or disapproving token holders (`approveHolder`, `disapproveHolder`), minting new tokens, adding or releasing managed NFTs (`addManagedNFT`, `releaseManagedNFT`), and setting the list of distributable ERC20 tokens (`setDistributableERC20s`). All these functions are safeguarded by OpenZeppelin's `Ownable` contract, which provides a standardized approach to access control. However, this reliance on a single Owner role introduces a potential vulnerability related to centralization, where a single point of failure could pose risks to the protocol's security and integrity.

### Recommendations
To mitigate this risk, it is strongly recommended to implement OpenZeppelin's Ownable2Step contract. This step enhances security by addressing centralization concerns in the protocol.

## Systemic Risk
### Risk Due to Removal of `_isApprovedOrOwner` in OpenZeppelin Contracts
OpenZeppelin (OZ) has recently made a significant update to their ERC721 contract by removing the `_isApprovedOrOwner()` internal function in the latest version. This change introduces a risk for contracts that rely on this function, such as the `OwnableApprovableERC721` contract and, by extension, the `LiquidInfrastructureNFT` contract. Since these contracts are built upon the assumption that `_isApprovedOrOwner()` is available for use, updating to the latest version of OpenZeppelin's contracts without appropriate modifications could lead to compatibility issues or even contract failure. It is crucial for developers and auditors to be aware of this change and to ensure that any contracts depending on `_isApprovedOrOwner()` are either updated to work with the new OpenZeppelin implementation or are locked to a compatible version of the OpenZeppelin contracts to mitigate potential risks associated with this breaking change.

### Absence of stringent access control on `distribute` and `withdrawFromManagedNFTs` 
The absence of stringent access control on pivotal functions like `distribute` and `withdrawFromManagedNFTs` presents a systemic risk that extends beyond individual contract vulnerabilities to potentially affect the entire ecosystem dependent on it. This risk materializes when unauthorized users are able to invoke these functions. This lack of control could lead to scenarios where users initiate distribution or withdrawal processes but do not complete them, consequently burdening other users or the owner with the task of finishing these operations. Such situations could render these vital contract functions idle, disrupting the contract's critical operations until the pending actions are resolved.

### Lack of Upgradability Provisions
The contract lacks a structured approach to upgradability. Without provisions for upgradability, deploying updates to address vulnerabilities or introduce improvements could pose challenges. Considering the integration of upgradability features is advisable to facilitate future enhancements and fixes.

### Absence of Pausability Feature
The contract currently lacks a pausability mechanism, a critical feature for emergency halting of contract functions in response to vulnerabilities or attacks. Introducing a pausability feature would enable a swift response to protect user funds and maintain system integrity during unforeseen events.



### Time spent:
48 hours